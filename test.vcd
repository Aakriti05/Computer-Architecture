$date
	Tue Apr 03 23:48:08 2018
$end
$version
	Icarus Verilog
$end
$timescale
	10ps
$end
$scope module tb_FSM $end
$upscope $end
$scope module tb_alu_16bit $end
$upscope $end
$scope module tb_append $end
$upscope $end
$scope module tb_comb_reg_sel $end
$upscope $end
$scope module tb_extend_12_to_16 $end
$upscope $end
$scope module tb_extend_4_to_16 $end
$upscope $end
$scope module tb_extend_8_to_16 $end
$upscope $end
$scope module tb_intreg $end
$upscope $end
$scope module tb_mdr $end
$upscope $end
$scope module tb_memory $end
$upscope $end
$scope module tb_mux_2to1 $end
$upscope $end
$scope module tb_mux_4to1 $end
$upscope $end
$scope module tb_pcreg $end
$upscope $end
$scope module tb_test_int $end
$var reg 1 ! clk $end
$var reg 1 " dout_temp $end
$var reg 1 # rst $end
$scope module uut $end
$var wire 1 ! clk $end
$var wire 1 $ pc_write $end
$var wire 1 # rst $end
$var wire 1 % temp_out $end
$var wire 1 & zerof $end
$var wire 16 ' writedata [15:0] $end
$var wire 4 ( readregsrc3 [3:0] $end
$var wire 4 ) readregsrc2 [3:0] $end
$var wire 4 * readregsrc1 [3:0] $end
$var wire 16 + pcaddout [15:0] $end
$var wire 16 , pcaddinp [15:0] $end
$var wire 16 - instr [15:0] $end
$var wire 1 . flag $end
$var wire 16 / dout_temp [15:0] $end
$var wire 16 0 data_temp [15:0] $end
$var wire 16 1 data [15:0] $end
$var wire 16 2 c [15:0] $end
$var wire 16 3 b [15:0] $end
$var wire 4 4 append11regadd [3:0] $end
$var wire 4 5 append10regadd [3:0] $end
$var wire 16 6 a [15:0] $end
$var wire 1 7 Resetzero $end
$var wire 1 8 RegWrite $end
$var wire 1 9 RegRead $end
$var wire 1 : ReadRegSrc3 $end
$var wire 1 ; ReadRegSrc2 $end
$var wire 1 < ReadRegSrc1 $end
$var wire 1 = PCWriteCond $end
$var wire 1 > PCWrite $end
$var wire 1 ? PCSrc $end
$var wire 1 @ MemtoReg $end
$var wire 1 A MemWrite $end
$var wire 1 B MemRead $end
$var wire 1 C IntMemRead $end
$var wire 1 D IRWrite $end
$var wire 1 E IRRead $end
$var wire 1 F FlagSel $end
$var wire 1 G ExOp $end
$var wire 3 H ALUop [2:0] $end
$var wire 16 I ALUSrc2_inp3 [15:0] $end
$var wire 16 J ALUSrc2_inp2 [15:0] $end
$var wire 2 K ALUSrc2 [1:0] $end
$var wire 16 L ALUSrc1_inp3 [15:0] $end
$var wire 2 M ALUSrc1 [1:0] $end
$var wire 16 N ALUOut [15:0] $end
$var wire 16 O ALUInp2 [15:0] $end
$var wire 16 P ALUInp1 [15:0] $end
$scope module alu $end
$var wire 3 Q op [2:0] $end
$var wire 16 R b [15:0] $end
$var wire 16 S a [15:0] $end
$var reg 16 T out [15:0] $end
$var reg 16 U temp_a [15:0] $end
$var reg 1 & zerof $end
$upscope $end
$scope module append10 $end
$var wire 2 V int_in [1:0] $end
$var reg 4 W int_out [3:0] $end
$upscope $end
$scope module append11 $end
$var wire 2 X int_in [1:0] $end
$var reg 4 Y int_out [3:0] $end
$upscope $end
$scope module controlsignal $end
$var wire 1 ! clk $end
$var wire 4 Z func [3:0] $end
$var wire 4 [ op [3:0] $end
$var wire 1 # rst $end
$var reg 2 \ ALUSrc1 [1:0] $end
$var reg 2 ] ALUSrc2 [1:0] $end
$var reg 3 ^ ALUop [2:0] $end
$var reg 3 _ CurrentState [2:0] $end
$var reg 1 G ExOp $end
$var reg 1 F FlagSel $end
$var reg 1 E IRRead $end
$var reg 1 D IRWrite $end
$var reg 1 C IntMemRead $end
$var reg 1 B MemRead $end
$var reg 1 A MemWrite $end
$var reg 1 @ MemtoReg $end
$var reg 3 ` NextState [2:0] $end
$var reg 1 ? PCSrc $end
$var reg 1 > PCWrite $end
$var reg 1 = PCWriteCond $end
$var reg 1 9 RegRead $end
$var reg 1 8 RegWrite $end
$var reg 1 7 Resetzero $end
$upscope $end
$scope module data_mem $end
$var wire 15 a adrb [14:0] $end
$var wire 1 ! clk $end
$var wire 1 B rb $end
$var wire 1 A wb $end
$var wire 16 b din [15:0] $end
$var reg 16 c dout [15:0] $end
$upscope $end
$scope module ex12to6 $end
$var wire 12 d in [11:0] $end
$var reg 16 e out [15:0] $end
$upscope $end
$scope module ex4to6 $end
$var wire 4 f in [3:0] $end
$var reg 16 g out [15:0] $end
$upscope $end
$scope module ex8to6 $end
$var wire 1 G ExOp $end
$var wire 8 h in [7:0] $end
$var reg 16 i out [15:0] $end
$upscope $end
$scope module instr_mem $end
$var wire 15 j adrb [14:0] $end
$var wire 1 ! clk $end
$var wire 1 C rb $end
$var reg 16 k dout [15:0] $end
$upscope $end
$scope module intreg $end
$var wire 1 E IRRead $end
$var wire 1 D IRWrite $end
$var wire 16 l int_in [15:0] $end
$var reg 16 m hidden [15:0] $end
$var reg 16 n int_out [15:0] $end
$upscope $end
$scope module mdr $end
$var wire 16 o data_in [15:0] $end
$var reg 16 p data_out [15:0] $end
$upscope $end
$scope module mux_ALUSrc1 $end
$var wire 16 q a [15:0] $end
$var wire 16 r d [15:0] $end
$var wire 2 s op [1:0] $end
$var wire 16 t c [15:0] $end
$var wire 16 u b [15:0] $end
$var reg 16 v out [15:0] $end
$upscope $end
$scope module mux_ALUSrc2 $end
$var wire 16 w b [15:0] $end
$var wire 16 x c [15:0] $end
$var wire 16 y d [15:0] $end
$var wire 2 z op [1:0] $end
$var wire 16 { a [15:0] $end
$var reg 16 | out [15:0] $end
$upscope $end
$scope module mux_MemtoReg $end
$var wire 16 } a [15:0] $end
$var wire 16 ~ b [15:0] $end
$var wire 1 @ op $end
$var reg 16 !" out [15:0] $end
$upscope $end
$scope module mux_RegSrc1 $end
$var wire 4 "" a [3:0] $end
$var wire 4 #" b [3:0] $end
$var wire 1 < op $end
$var reg 4 $" out [3:0] $end
$upscope $end
$scope module mux_RegSrc2 $end
$var wire 4 %" a [3:0] $end
$var wire 4 &" b [3:0] $end
$var wire 1 ; op $end
$var reg 4 '" out [3:0] $end
$upscope $end
$scope module mux_RegSrc3 $end
$var wire 4 (" a [3:0] $end
$var wire 4 )" b [3:0] $end
$var wire 1 : op $end
$var reg 4 *" out [3:0] $end
$upscope $end
$scope module mux_zerof $end
$var wire 1 & a $end
$var wire 1 +" b $end
$var wire 1 F op $end
$var reg 1 . out $end
$upscope $end
$scope module muxex_sel $end
$var wire 2 ," func [1:0] $end
$var wire 4 -" opcode [3:0] $end
$var reg 1 < ReadRegSrc1 $end
$var reg 1 ; ReadRegSrc2 $end
$var reg 1 : ReadRegSrc3 $end
$upscope $end
$scope module pcmux $end
$var wire 16 ." a [15:0] $end
$var wire 1 ? op $end
$var wire 16 /" b [15:0] $end
$var reg 16 0" out [15:0] $end
$upscope $end
$scope module pcreg $end
$var wire 1 $ PCWrite $end
$var wire 1 7 Resetzero $end
$var wire 15 1" pcaddinp [14:0] $end
$var reg 15 2" pcaddout [14:0] $end
$upscope $end
$scope module regfile $end
$var wire 1 ! clk $end
$var wire 4 3" readregsrc1 [3:0] $end
$var wire 4 4" readregsrc2 [3:0] $end
$var wire 4 5" readregsrc3 [3:0] $end
$var wire 1 9 regread $end
$var wire 1 8 regwrite $end
$var wire 4 6" regwritedst [3:0] $end
$var wire 16 7" writedata [15:0] $end
$var reg 16 8" a [15:0] $end
$var reg 16 9" b [15:0] $end
$var reg 16 :" c [15:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module tst_regfile $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx :"
bx 9"
bx 8"
bx 7"
bx 6"
bx 5"
bx 4"
bx 3"
bx 2"
bx 1"
bx 0"
bx /"
bx ."
bx -"
bx ,"
z+"
bx *"
bx )"
bx ("
bx '"
bx &"
bx %"
bx $"
bx #"
bx ""
bx !"
bx ~
bx }
bx |
bx {
bx z
bx y
bx x
b10 w
bx v
bx u
bx t
bx s
bx r
bzxxxxxxxxxxxxxxx q
bx p
bx o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
xG
xF
xE
xD
xC
xB
xA
x@
x?
x>
x=
x<
x;
x:
x9
x8
x7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
x.
bx -
bx ,
bzxxxxxxxxxxxxxxx +
bx *
bx )
bx (
bx '
x&
x%
x$
1#
x"
0!
$end
#500
1!
0#
#1000
0!
#1500
1!
#2000
0!
#2500
1!
#3000
0!
#3500
1!
#4000
0!
#4500
1!
#5000
0!
#5500
1!
#6000
0!
#6500
1!
#7000
0!
#7500
1!
#8000
0!
#8500
1!
#9000
0!
#9500
1!
#10000
0!
#10500
1!
